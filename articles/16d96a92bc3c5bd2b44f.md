---
title: "Magnet Patternã¨Method Overloading"
emoji: "ğŸ§²"
type: "tech"
topics: ["scala", "akka", "magnetpattern"]
published: false
---

# ã¯ã˜ã‚ã«
ç¤¾å†…å‹‰å¼·ä¼šã§Magnet Patternã«ã¤ã„ã¦ã¾ã¨ã‚ã¦è©±ã—ãŸã®ã§ã€è©±ã—ãŸå†…å®¹ã«ã¤ã„ã¦è¨˜äº‹ã«ã¾ã¨ã‚ã¾ã—ãŸã€‚ãã®éš›ã«ä½œæˆã‚¹ãƒ©ã‚¤ãƒ‰ã¯[ã“ã¡ã‚‰](https://speakerdeck.com/kentarousuzuki/magnet-pattern-to-method-overload)ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸã®ã§ã€ã‚¹ãƒ©ã‚¤ãƒ‰ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’ã¿ãŸã„æ–¹ã¯ã”è¦§ä¸‹ã•ã„ã€‚

# Magnet PatternãŒè§£æ±ºã™ã‚‹å•é¡Œ
ä»Šå›ç´¹ä»‹ã™ã‚‹Magnet Patternã¯[ã“ã¡ã‚‰ã®sprayã®ãƒ–ãƒ­ã‚°](http://spray.io/blog/2012-12-13-the-magnet-pattern/)ã§è©³ã—ãç´¹ä»‹ã•ã‚Œã¦ãŠã‚Šã€ã“ã¡ã‚‰ã®å®Ÿè£…ã‚’ç”¨ã„ã¦Akka HTTPã®completeé–¢æ•°ãªã©ãŒå®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã¾ã™ã€‚ã“ã®ãƒ–ãƒ­ã‚°ã§ã¯ã€ä»¥ä¸‹ã®æ§˜ãªæ–‡ç« ã‚’å¼•ç”¨ã—ãŸä¸Šã§ã€Scala APIã‚’ãƒ‡ã‚¶ã‚¤ãƒ³ã™ã‚‹éš›ã«ã€Œåä»˜ã‘ã€ã®å•é¡Œã¯å¤§ããªèª²é¡Œã ã¨ã—ã¦ã„ã¾ã™ã€‚ãã—ã¦ã€Magnet Patternåä»˜ã‘ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ã¨è¿°ã¹ã¦ã„ã¾ã™ã€‚
> There are only two hard things in Computer Science: cache invalidation, naming things and off-by-1 errors.
> â€”Phil Karlton (slightly adapted)

ã¾ãšã¯ã€ã“ã®åä»˜ã‘ã®å•é¡Œã¨ã¯ã©ã®ã‚ˆã†ãªå•é¡Œãªã®ã‹ã€å…·ä½“çš„ã«èª¬æ˜ã—ã¾ã™ã€‚

## åä»˜ã‘ã®å•é¡Œã¨ã¯?
ä¾‹ãˆã°ã€ä»¥ä¸‹ã®æ§˜ãªè¦ä»¶ã‚’æƒ³å®šã—ã¾ã™ã€‚
- `ListGenerator`ã«å¯¾ã—ã¦å€¤ã‚’æ¸¡ã—ã¦ã€Listã®è¿”ã‚Šå€¤ã‚’å¾—ã‚‹
- æƒ³å®šã—ã¦ã„ã‚‹å¼•æ•°ã¨è¿”ã‚Šå€¤ã¯ä»¥ä¸‹ã®è¡¨ã®é€šã‚Š

| å¼•æ•°ã®å€¤              | å¼•æ•°ã®å‹      | è¿”ã‚Šå€¤                 | è¿”ã‚Šå€¤ã®å‹   | 
| -------------------- | ------------ | --------------------- | ---------- | 
| 1                    | Int          | List(1)               | List[Int]  | 
| "Hoge"               | String       | List(H, o, g, e)      | List[Char] | 
| List(1, 2)           | List[Int]    | List(1, 2)            | List[Int]  | 
| List("Hoge", "Fuga") | List[String] | List(H,o,g,e,F,u,g,a) | List[Char] | 

ã“ã®ã‚ˆã†ãªè¦ä»¶ãŒã‚ã£ãŸéš›ã«ã€æƒ³å®šã•ã‚Œã‚‹å®Ÿè£…ã®ä¾‹ã¨ã—ã¦ã¯
```scala
val fromInt = ListGenerator.generate(1)
val fromStr = ListGenerator.generate("hoge")

// val fromInt: List[Int] = List(1)
// val fromStr: List[Char] = List(h, o, g, e)
```
ã®ã‚ˆã†ãªå®Ÿè£…ãŒæƒ³å®šã§ãã¾ã™ã€‚
ã“ã®æ™‚ã«ListGeneratorã«å®šç¾©ã•ã‚Œã‚‹generateãƒ¡ã‚½ãƒƒãƒ‰ã®åå‰ã‚’é©åˆ‡ãªã‚‚ã®ã«ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã¨ã„ã†ã“ã¨ãŒã€ã“ã“ã§è¿°ã¹ã‚‰ã‚Œã¦ã„ã‚‹ã€Œåä»˜ã‘ã€ã®å•é¡Œã§ã™ã€‚

## Method Overloadingã‚’ä½¿ã£ãŸå®Ÿè£…
ã•ã¦ã€ã§ã¯å®Ÿè£…ã«ã©ã®ã‚ˆã†ã«è¦ä»¶ã‚’å®Ÿç¾ã™ã‚‹ã®ã‹è€ƒãˆã¾ã—ã‚‡ã†ã€‚ä¾‹ãˆã°ã€`ListGenerator.generate`ã«å¼•æ•°ã‚’æ¸¡ã™ã¨ãã€Scalaã¯é™çš„å‹ä»˜ã‘è¨€èªãªã®ã§ã€å¼•æ•°ã«æ¸¡ã›ã‚‹å€¤ã®å‹ã‚’ã‚ã‚‰ã‹ã˜ã‚æ±ºã‚ã¦ãŠã‹ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ãã“ã§Method Overloadingã‚’ä½¿ã£ã¦è¤‡æ•°ã®å‹ã‚’æ¸¡ã›ã‚‹æ§˜ã«ã—ã¾ã™ã€‚

```scala
object ListGenerator {
	def generateFromInt(x: Int): List[Int] = x::Nil
	def generateFromStr(x: String): List[Char] = x.map(_.toChar).toList
}

val fromInt = ListGenerator.generateFromInt(1)
val fromStr = ListGenerator.generateFromStr("hoge")

// val fromInt: List[Int] = List(1)
// val fromStr: List[Char] = List(h, o, g, e)
```

ã„ã„æ„Ÿã˜ã§ã™ã­ã€‚ã§ã¯ã€Intã‚„Stringã ã‘ã§ã¯ãªãã€List[Int]ã‚„List[String]ã‚‚æ¸¡ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã—ã‚‡ã†ã€‚ã™ã‚‹ã¨ä»¥ä¸‹ã®ã‚ˆã†ãªå®Ÿè£…ãŒã§ãã¾ã™ã€‚
 
```scala
object ListGenerator {
	def generate(x: Int): List[Int] = x::Nil
	def generate(x: String): List[Char] = x.map(_.toChar).toList
	def generate(x: List[Int]): List[Int] = x
	def generate(x: List[String]): List[Char] = x.flatMap(_.map(_.toChar).toList)
}

val fromInt = ListGenerator.generate(1)
val fromStr = ListGenerator.generate("hoge")
val fromIntList = ListGenerator.generate(List(1, 2, 3, 4))
val fromStrList = ListGenerator.generate(List("hoge", "fuga"))
```

ã—ã‹ã—ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ä»¥ä¸‹ã®ã‚¨ãƒ©ãƒ¼ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚

```
double definition:
def generate(x: List[Int]): List[Int] at line 4 and
def generate(x: List[String]): List[Char] at line 5
have same type after erasure: (x: List): List
        def generate(x: List[String]): List[Char] = x.flatMap(_.map(_.toChar).toList)
            ^
Compilation Failed
```

ãªãœã€ã‚¨ãƒ©ãƒ¼ãŒå‡ºåŠ›ã•ã‚ŒãŸã®ã§ã—ã‚‡ã†ã‹? 

## å‹æ¶ˆå»ã¨ã¯?
å‡ºåŠ›ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’èª­ã‚“ã§ã¿ã‚‹ã¨`def generate`ã«ã¯åŒã˜å‹ãŒæ¸¡ã•ã‚Œã¦ã„ã‚‹ã¨æ›¸ã„ã¦ã‚ã‚Šã¾ã™ã€‚ä»Šå›ã®ã‚³ãƒ¼ãƒ‰ã§ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒå¤±æ•—ã—ãŸåŸå› ã¯ã€å‹æ¶ˆå»(type erasure)ãŒèµ·ããŸã“ã¨ã§List[Int]ã¨List[String]ãŒListã¨ã—ã¦å®šç¾©ã•ã‚Œã€Listã‚’å¼•æ•°ã¨ã—ã¦å—ã‘å–ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ãŒé‡è¤‡ã—ãŸã“ã¨ã§ã™ã€‚å‹æ¶ˆå»ã¨ã¯ã€ç°¡å˜ã«èª¬æ˜ã™ã‚‹ã¨ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ç·ç§°å‹(ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹)ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒæ¶ˆå»ã•ã‚Œã‚‹ã“ã¨ã§ã™ã€‚ä»Šå›ã®ã‚³ãƒ¼ãƒ‰ã®å ´åˆã¯ `List[Int]` ã¨ `List[String]` ã§åˆ¥ã€…ã«å®šç¾©ã•ã‚Œã¦ã„ãŸãƒ¡ã‚½ãƒƒãƒ‰ã§å¼•æ•°ã®å‹æ¶ˆå»ã•ã‚Œã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¾Œã«ã¯ã©ã¡ã‚‰ã‚‚ `List` ã¨ã—ã¦å‹ãŒå®šç¾©ã•ã‚Œã¾ã™ã€‚ãã®ãŸã‚ã€Listå‹ä»¥å¤–ã«ã‚‚Optionå‹ã§ã‚‚ä»¥ä¸‹ã®æ§˜ã«å‹æ¶ˆå»ã«ã‚ˆã‚‹å‹ã®ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒç™ºç”Ÿã—ã¾ã™ã€‚

```scala
object ListGenerator {
	def generate(x: Int): List[Int] = x::Nil
	def generate(x: String): List[Char] = x.map(_.toChar).toList
	def generate(x: Option[Int]): List[Int] = x.toList
	def generate(x: Option[String]): List[Char] = x.map(_.map(_.toChar).toList).getOrElse(Nil)
}

val fromInt = ListGenerator.generate(1)
val fromStr = ListGenerator.generate("hoge")
val fromIntOpt = ListGenerator.generate(Option(1))
val fromStrOpt = ListGenerator.generate(Option("hoge"))

// double definition:
// def generate(x: Option[Int]): List[Int] at line 4 and
// def generate(x: Option[String]): List[Char] at line 5
// have same type after erasure: (x: Option): List
//         def generate(x: Option[String]): List[Char] = x.map(_.map(_.toChar).toList).getOrElse(Nil)
//             ^
// Compilation Failed
```

ã“ã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ™‚ã«å‹æ¶ˆå»ã™ã‚‹ã®ã¯Javaã®ä»•æ§˜ã§ã‚ã‚Šã€[Oracleã®Java8ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://docs.oracle.com/javase/jp/8/docs/technotes/guides/language/generics.html)ã«ã‚‚æ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚
> ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã¯å‹æ¶ˆå»ã«ã‚ˆã£ã¦å®Ÿè£…ã•ã‚Œã¾ã™ã€‚ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹æƒ…å ±ã¯ã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ã—ã‹å­˜åœ¨ã›ãšã€ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¾Œã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«ã‚ˆã£ã¦æ¶ˆå»ã•ã‚Œã¾ã™ã€‚ã“ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®ä¸»ãªåˆ©ç‚¹ã¨ã—ã¦ã¯ã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ»ã‚³ãƒ¼ãƒ‰ã¨ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã•ã‚Œã¦ã„ãªã„å‹(æŠ€è¡“çš„ã«ã¯rawå‹ã¨å‘¼ã°ã‚Œã‚‹)ã‚’ä½¿ç”¨ã™ã‚‹ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ»ã‚³ãƒ¼ãƒ‰ã¨ã®é–“ã«ã€ç·åˆçš„ãªç›¸äº’é‹ç”¨æ€§ãŒå®Ÿç¾ã™ã‚‹ç‚¹ã§ã™ã€‚ä¸»ãªçŸ­æ‰€ã¨ã—ã¦ã¯ã€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å‹æƒ…å ±ã‚’å®Ÿè¡Œæ™‚ã«åˆ©ç”¨ã§ããªã„ç‚¹ã¨ã€å‹•ä½œãŒé©åˆ‡ã§ãªã„ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ»ã‚³ãƒ¼ãƒ‰ã¨ç›¸äº’é‹ç”¨ã™ã‚‹ã¨ã€è‡ªå‹•çš„ã«ç”Ÿæˆã•ã‚ŒãŸã‚­ãƒ£ã‚¹ãƒˆãŒå¤±æ•—ã™ã‚‹æã‚ŒãŒã‚ã‚‹ç‚¹ã§ã™ã€‚ã—ã‹ã—ã€å‹•ä½œãŒé©åˆ‡ã§ãªã„ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ»ã‚³ãƒ¼ãƒ‰ã¨ç›¸äº’é‹ç”¨ã™ã‚‹ã¨ãã‚‚ã€ã‚¸ã‚§ãƒãƒªãƒƒã‚¯ãƒ»ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã«å¯¾ã—ã¦å®Ÿè¡Œæ™‚ã®å‹ã®å®‰å…¨æ€§ã‚’ä¿è¨¼ã™ã‚‹æ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚

## å®šç¾©ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰åã‚’å¤‰ãˆã‚‹
å¼•æ•°ã®å‹æ¶ˆå»ã«ã‚ˆã‚‹å‹ã®è¡çªã‚’å›é¿ã™ã‚‹ãŸã‚ã«ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«ãƒ¡ã‚½ãƒƒãƒ‰ã®åå‰ã‚’å¤‰æ›´ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä»¥ä¸‹ã®ä¾‹ã«ç¤ºã—ãŸã‚³ãƒ¼ãƒ‰ã§ã¯Intã€Stringã€List[Int]ã€List[String]ã‹ã‚‰ãã‚Œãã‚Œã«å¯¾å¿œã™ã‚‹Listå‹ã‚’ç”Ÿæˆã§ãã‚‹ã‚ˆã†ã«ãƒ¡ã‚½ãƒƒãƒ‰åã‚’å¤‰ãˆã¦å®Ÿè£…ã—ã¦ã‚ã‚Šã¾ã™ã€‚

```scala
object ListGenerator {
	def generateFromInt(x: Int): List[Int] = x::Nil
	def generateFromStr(x: String): List[Char] = x.map(_.toChar).toList
	def generateFromIntList(x: List[Int]): List[Int] = x
	def generateFromStrList(x: List[String]): List[Char] = x.flatMap(_.map(_.toChar).toList)
}

val fromInt = ListGenerator.generateFromInt(1)
val fromStr = ListGenerator.generateFromStr("hoge")
val fromIntList = ListGenerator.generateFromIntList(List(1, 2, 3, 4))
val fromStrList = ListGenerator.generateFromStrList(List("hoge", "fuga"))

// val fromInt: List[Int] = List(1)
// val fromStr: List[Char] = List(h, o, g, e)
// val fromIntList: List[Int] = List(1, 2, 3, 4)
// val fromStrList: List[Char] = List(h, o, g, e, f, u, g, a)
```

ç¢ºã‹ã«ã€ã“ã¡ã‚‰ã®å®Ÿè£…ã ã¨å¼•æ•°ã®å‹æ¶ˆå»ãŒèµ·ãã¦ã‚‚ã€ãƒ¡ã‚½ãƒƒãƒ‰ãŒç•°ãªã‚‹ãŸã‚ã«å‹ã®è¡çªãŒç™ºç”Ÿã—ã¾ã›ã‚“ã€‚ã—ã‹ã—ã€ãã‚Œãã‚Œã®ãƒ¡ã‚½ãƒƒãƒ‰åã¯generateFromXXã¨ãªã£ã¦ãŠã‚Šã€ã‚„ã‚„å†—é•·ãªå°è±¡ã‚’å—ã‘ã¾ã™ã€‚ã“ã®æ™‚æœŸã§ç´¹ä»‹ã™ã‚‹Magnet Methodã¯ã“ã®ã‚ˆã†ãªã€Œåä»˜ã‘ã€ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã¾ã™ã€‚

# Magnet Patternã®ä»•çµ„ã¿
ã¾ãšã¯ã€Magnet Patternã®å®Ÿè£…ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```scala
trait ListGeneratorMagnet {
	type Out
	def list(): Out
}

implicit def intMagnet(x: Int) = new ListGeneratorMagnet {
	type Out = List[Int]
	def list(): Out = x::Nil
}

implicit def strMagnet(x: String) = new ListGeneratorMagnet {
	type Out = List[Char]
	def list(): Out = x.map(_.toChar).toList
}

implicit def intListMagnet(x: List[Int]) = new ListGeneratorMagnet {
	type Out = List[Int]
	def list(): Out = x
}

implicit def strListMagnet(x: List[String]) = new ListGeneratorMagnet {
	type Out = List[Char]
	def list(): Out = x.flatMap(_.map(_.toChar).toList)
}

object ListGenerator {
	def generate(magnet: ListGeneratorMagnet): magnet.Out = magnet.list()
}

val fromInt = ListGenerator.generate(1)
val fromStr = ListGenerator.generate("hoge")
val fromIntList = ListGenerator.generate(List(1, 2, 3))
val fromStrList = ListGenerator.generate(List("hoge", "fuga"))

// val fromInt: List[Int] = List(1)
// val fromStr: List[Char] = List(h, o, g, e)
// val fromIntList: List[Int] = List(1, 2, 3, 4)
// val fromStrList: List[Char] = List(h, o, g, e, f, u, g, a)
```

ã“ã®ã‚³ãƒ¼ãƒ‰ã‚’ç†è§£ã™ã‚‹ä¸Šã§ã€ãƒã‚¤ãƒ³ãƒˆã¨ãªã‚‹ã®ã¯ `ListGeneratorMagnet` ã¨ `implicit def` ã§ã™ã€‚ãã“ã§ã¾ãšã¯ `ListGeneratorMagnet` ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚

## ListGeneratorMagnet
ã“ã®ListGeneratorMagentã¯ä»˜ã‘ã‚‰ã‚ŒãŸåå‰ã®é€šã‚Šã€Magnet(ç£çŸ³)ã¨ã—ã¦ãƒ¡ã‚½ãƒƒãƒ‰ã¨å¼•æ•°ã‚’çµã³ã¤ã‘ã‚‹å½¹å‰²ã‚’ã—ã¾ã™ã€‚ã“ã®ListGeneratorMagnetã«ã¯ `type Out` ã¨ `def list(): Out` ãŒå®šç¾©ã•ã‚Œã¦ãŠã‚Šã€ `ListGenerator.generate` ã«æ¸¡ã™å‹ã”ã¨ã«å…·ä½“çš„ãªå®Ÿè£…ã‚’ã—ã¾ã™ã€‚
ä¾‹ãˆã°ã€intMagnetã®å®Ÿè£…ã‚’è¦‹ã¦ã„ãã¾ã—ã‚‡ã†ã€‚

```scala
implicit def intMagnet(x: Int) = new ListGeneratorMagnet {
	type Out = List[Int] // å—ã‘å–ã£ãŸx: Intã‚’å¤‰æ›ã—ãŸå…ˆã®å‹
	def list(): Out = x::Nil // x: Intã‚’type Outã«å¤‰æ›ã™ã‚‹å…·ä½“çš„ãªãƒ­ã‚¸ãƒƒã‚¯
}
```

intMagnetã§ã¯ã¾ãšã€ `type Out = List[Int]` ã¨å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯Scala2.10ã§è¿½åŠ ã•ã‚ŒãŸDependent Method Typeã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚Dependent Method Typeã¯ã“ã‚ŒãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å¤‰æ•°ã¨ã—ã¦æ¸¡ã—ã€Dependent Method Typeã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§å®šç¾©ã•ã‚Œã¦ã„ã‚‹å‹ã‚’è¿”ã™æ©Ÿèƒ½ã«ãªã£ã¦ã„ã¾ã™ã€‚ä»Šå›ã®ã‚³ãƒ¼ãƒ‰ã§ã¯generateãƒ¡ã‚½ãƒƒãƒ‰ã®è¿”ã‚Šå€¤ã®å‹ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ä¾‹ãˆã°ã€generateãƒ¡ã‚½ãƒƒãƒ‰ã®å¼•æ•°ã«intMagnetã‚’æ¸¡ã›ã°List[Int]ãŒè¿”ã‚Šå€¤ã®å‹ã¨ã—ã¦å®šç¾©ã•ã‚Œã€strMagnetã‚’æ¸¡ã›ã°List[Char]ã‚’è¿”ã™ã¨ã„ã†ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ä»Šå›ã® `type Out` ã«ã¯æ¸¡ã—ãŸå¼•æ•°ã®è¿”ã‚Šå€¤ã¨ã—ã¦è¿”ã—ãŸã„å€¤ã®å‹ã‚’å®šç¾©ã—ã¾ã™ã€‚
ãã—ã¦ã€intMagnetã«ã¯list()ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã“ã«ã¯æ¸¡ã£ã¦ãã‚‹å€¤ã‚’è¿”ã—ãŸã„å€¤ã«å¤‰æ›ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ›¸ãã¾ã™ã€‚ä¾‹ãˆã°ã€intMagetã§ã¯Intå‹ã®å€¤ãŒæ¸¡ã£ã¦ãã¦ã€ãã‚Œã‚’Int[List]ã«å¤‰æ›ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ›¸ãã¾ã™ã€‚åŒã˜ã‚ˆã†ã«strMagentã§ã¯Stringã‚’List[Char]ã«å¤‰æ›ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã‚’æ›¸ãã¾ã™ã€‚ãã—ã¦ã€intMagnetã‚„strMagnetã§å®Ÿè£…ã•ã‚ŒãŸlist()ã¯ListGeneratorã§magnet.list()ã®ã‚ˆã†ã«å‘¼ã³å‡ºã•ã‚Œã¦ã„ã¾ã™ã€‚

## implicit def
ã•ã¦ã€ä¾‹ã¨ã—ã¦ç¤ºã—ãŸListGenerator.generateã«ã¯ListGeneratorMagnetã‚’æ¸¡ã™ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€å®Ÿéš›ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã¨ã“ã‚ã§ã¯`1`ã‚„`"hoge"`ã®ã‚ˆã†ãªListGenerarotMagnetã§ã¯ãªã„å€¤ã‚’æ¸¡ã—ã¦ã„ã¾ã™ã€‚ãªãœã€ãã®ã‚ˆã†ãªå€¤ã‚’æ¸¡ã—ã¦ã‚‚å¤§ä¸ˆå¤«ãªã®ã‹ã€‚ãã‚Œã¯`implicit def`ã§æš—é»™ã®å¤‰æ›ã‚’ã—ã¦ã„ã‚‹ã‹ã‚‰ã§ã™ã€‚ä¾‹ãˆã°ã€generateãƒ¡ã‚½ãƒƒãƒ‰ã«`1`ãŒæ¸¡ã•ã‚ŒãŸå ´åˆã‚’è€ƒãˆã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã“ã®æ™‚ã€intMagnetãŒå®šç¾©ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã«ã€generateãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚ŒãŸ`1`ã¯Intå‹ã‹ã‚‰ListGeneratorMagnetå‹ã«å¤‰æ›ã•ã‚Œã¦ã€generateãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã•ã‚Œã¾ã™ã€‚ã—ãŸãŒã£ã¦ã€ã“ã“ã§ã¯implicit defã§ListGeneratorMagnetå‹ã¸ã®å¤‰æ›æ–¹æ³•ãŒå®šç¾©ã•ã‚Œã¦ã„ãªã„Floatå‹ã‚’generateãƒ¡ã‚½ãƒƒãƒ‰ã«æ¸¡ã—ãŸå ´åˆä»¥ä¸‹ã®ã‚ˆã†ãªã‚¨ãƒ©ãƒ¼ãŒå‡ºåŠ›ã•ã‚Œã¾ã™ã€‚

```
type mismatch;
 found   : Float(1.0)
 required: ListGeneratorMagnet
val fromFloat = ListGenerator.generate(1.0f)
                                    ^
Compilation Failed
```

## Scala3ã§ã®å¤‰æ›´
å…ˆæ—¥ã€Scala3ãŒãƒªãƒªãƒ¼ã‚¹ã•ã‚Œã¾ã—ãŸã€‚

@[tweet](https://twitter.com/scala_lang/status/1393139114535444484)

æ–°ã—ããƒªãƒªãƒ¼ã‚¹ã•ã‚ŒãŸScala3ã§ã¯ä»¥å‰ã®ã‚‚ã®ã¨æ¯”ã¹ã¦æ–‡æ³•ãŒå¤‰æ›´ã•ã‚ŒãŸã‚‚ã®ãŒã‚ã‚Šã¾ã™ã€‚ãã®ä¸­ã®ä¸€ã¤ã«ä»Šå›ã®Magnet Patternã‚’å®Ÿç¾ã™ã‚‹ã«ã‚ãŸã£ã¦åˆ©ç”¨ã—ãŸimplicit defã‚‚å«ã¾ã‚Œã¾ã™ã€‚Scala3ã§ã¯æš—é»™ã®å¤‰æ›(implicit def)ã¯ä»¥ä¸‹ã®æ§˜ã«å®Ÿè£…ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸã€‚

```scala
given Conversion[String, Token] with
  def apply(str: String): Token = new KeyWord(str)
```

[Scala3ã®ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã‚ˆã‚Šå¼•ç”¨](http://dotty.epfl.ch/docs/reference/contextual/conversions.html)

ã“ã®æ–‡æ³•ã®å¤‰æ›´ã‚’è¸ã¾ãˆã¦ã€Scala3ã§Magnet Patternã‚’å®Ÿç¾ã¨ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

```scala
import scala.language.implicitConversions
â€‹
trait ListGeneratorMagnet {
	type Out
	def list(): Out
}
â€‹
given fromInt:  Conversion[Int, ListGeneratorMagnet] with
	def apply(x: Int): ListGeneratorMagnet = new ListGeneratorMagnet {
		type Out = List[Int]
		def list(): Out = x::Nil
	}

object ListGenerator {
	def generate(magnet: ListGeneratorMagnet): magnet.Out = magnet.list()
}

ListGenerator.generate(1)
// val res0: ListGeneratorMagnet#Out = List(1)
```

# ã¾ã¨ã‚
ã“ã®è¨˜äº‹ã§ã¯Akka HTTPã®completeãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã§ã‚‚åˆ©ç”¨ã•ã‚Œã¦ã„ã‚‹Magnet Patternã®ä»•çµ„ã¿ã«ã¤ã„ã¦ç´¹ä»‹ã—ã¾ã—ãŸã€‚sprayã®ãƒ–ãƒ­ã‚°ã§ã¯ã€Œåä»˜ã‘ã€ã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«Magnet PatternãŒç´¹ä»‹ã•ã‚Œã¾ã—ãŸã€‚Scalaã§ã¯Method Overloadingã‚’ä½¿ã£ã¦åŒã˜ãƒ¡ã‚½ãƒƒãƒ‰åã§ã‚‚ç•°ãªã‚‹å¼•æ•°ã®å‹ã‚’æ¸¡ã›ã‚‹æ§˜ã«å®šç¾©ãŒã§ãã¾ã™ã€‚ã—ã‹ã—ã€ç·ç§°å‹ã®å€¤ã‚’å¼•æ•°ã«å®šç¾©ã™ã‚‹ã¨ã€å‹æ¶ˆå»ã«ã‚ˆã£ã¦å¼•æ•°ã®å‹ãŒè¡çªã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã®å•é¡Œã‚’å›é¿ã™ã‚‹ãŸã‚ã«generateFromInt, generateFromStringã®ã‚ˆã†ã«ãƒ¡ã‚½ãƒƒãƒ‰åã‚’å¤‰ãˆã¦å®Ÿè£…ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ãŸã ã€å¼•æ•°ã®å‹ã®è¡çªã‚’å›é¿ã™ã‚‹ãŸã‚ã«ãƒ¡ã‚½ãƒƒãƒ‰åã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ã¯æ™‚ã«é©åˆ‡ã§ãªã„ã€Œåä»˜ã‘ã€ã‚’ã—ãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚ãã®å•é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«Magnet PatternãŒä½¿ã‚ã‚Œã¾ã™ã€‚Magnet Patternã§ã¯Dependency Type Methodã§ãƒ¡ã‚½ãƒƒãƒ‰ã®è¿”ã‚Šå€¤ã®å‹ã¨ãã‚Œãã‚Œã®å‹ã‚’å¤‰æ›ã™ã‚‹ãŸã‚ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®šç¾©ã•ã‚ŒãŸMagnetã‚’å¼•æ•°ã«å—ã‘å–ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®šç¾©ã—ã¾ã™ã€‚ã•ã‚‰ã«ã€ãã®ãƒ¡ã‚½ãƒƒãƒ‰ã«å¼•æ•°ã‚’æ¸¡ã™ãŸã‚ã«implicit defã§æš—é»™çš„ã«å‹ã‚’å¤‰æ›ã—ã€å€¤ã‚’æ¸¡ã—ã¾ã™ã€‚Scala3ã§ã¯ã“ã®æš—é»™çš„ã«å‹ã‚’å¤‰æ›ã™ã‚‹ãŸã‚ã®æ–‡æ³•ã¯å¤‰æ›´ã•ã‚Œã¾ã—ãŸãŒã€‚ãã®æ–‡æ³•ã‚’ä½¿ã†ã“ã¨ã§å¼•ãç¶šãMagnet Patternã‚’ä½¿ã£ã¦ã€ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚

# å‚è€ƒURL
[spray | The Magnet Pattern](http://spray.io/blog/2012-12-13-the-magnet-pattern/)
[Java8 Generics](https://docs.oracle.com/javase/jp/8/docs/technotes/guides/language/generics.html)
[Scala3 Reference | Implicit Conversions](http://dotty.epfl.ch/docs/reference/contextual/conversions.html)
